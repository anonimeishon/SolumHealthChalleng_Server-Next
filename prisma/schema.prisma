// schema.prisma
// This file defines your Prisma schema, which maps to your database tables.
// It's used by Prisma Client to interact with your database.

// Configure your database connection.
// Replace "postgresql" with "sqlite" or "mysql" if you use a different database.
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Core Entities ---

// Represents a company or clinic (e.g., 'Clinic A', 'Clinic B').
model Company {
  id     Int     @id @default(autoincrement()) // Unique identifier for the company
  name   String  @unique // Name of the company/clinic, must be unique
  agents Agent[] // Relation: A company can have multiple agents
  calls  Call[] // Relation: A company can have multiple calls
}

// Represents an AI agent that handles calls.
model Agent {
  id          Int    @id @default(autoincrement()) // Unique identifier for the agent
  external_id String @unique // Unique identifier for the agent from the source spreadsheet
  company_id  Int    @map("companyId") // Foreign key to the Company table
  name        String // Name of the agent
  // agent_type field can be added here if an agent has a fixed type (e.g., 'Inbound', 'Outbound')
  // If agent type varies per call, it should be on the Call model instead.
  // agent_type  String?

  company Company @relation(fields: [company_id], references: [id]) // Relation: An agent belongs to one company
  calls   Call[] // Relation: An agent can handle multiple calls
}

// Represents a user, specifically your QA team members who perform evaluations.
model User {
  id                Int               @id @default(autoincrement()) // Unique identifier for the user
  name              String // User's name 
  email             String            @unique // User's email, must be unique
  role              String // User's role (e.g., "QA_Manager", "QA_Agent")
  human_evaluations HumanEvaluation[] // Relation: A user can perform multiple human evaluations
}

// --- Enum for Evaluation Type ---
// Defines the possible types of evaluations: Human or LLM.
enum EvaluationType {
  HUMAN // Evaluation performed by a human QA team member
  LLM // Evaluation generated by an LLM-based judge
}

enum TranscriptionStatus {
  NOT_STARTED // No transcription has been attempted
  PENDING     // Transcription is in progress
  FINISHED    // Transcription completed successfully
  FAILED      // Transcription failed
}

// --- Main Data Table for Calls ---
// This table stores details about each call handled by the AI agents.
// It includes common fields and nullable fields for clinic-specific data.

model Call {
  id               Int      @id @default(autoincrement()) // Unique identifier for the call
  external_id            String              @unique // The original unique ID from the source spreadsheet
  company_id             Int                 @map("companyId") // Foreign key to the Company table
  transcript             String?             @db.Text // Full transcript of the call (nullable)
  transcription_status   TranscriptionStatus @default(NOT_STARTED) // Status of transcript generation
  agent_id               Int                 @map("agentId") // Foreign key to the Agent table
  start_date       DateTime @map("startDate") // Date and time when the call occurred
  end_date         DateTime @map("endDate") // Date and time when the call occurred
  duration_seconds Int // Duration of the call in seconds
  recording_url    String // URL to the call audio recording

  // --- Common & Clinic-Specific Call Details (All Nullable) ---
  // These fields are designed to capture various data points that might appear
  // across different clinic spreadsheets. They are nullable because not all
  // data points will be present for every call or every clinic.

  customer_identifier String? // e.g., Patient ID, Account Number (nullable)
  call_type           String? // e.g., 'Inbound', 'Outbound', 'Triage' (nullable)
  call_status         String? // e.g., 'Completed', 'Abandoned', 'Transferred' (nullable)
  reason_for_call     String? // e.g., 'Appointment Booking', 'Billing Inquiry' (nullable)
  department          String? // e.g., 'Cardiology', 'Pediatrics' (nullable)
  service_provided    String? // e.g., 'Consultation', 'Prescription Refill' (nullable)
  ended_reason        String? // e.g., 'Customer Hangup', 'Agent Hangup' (nullable)
  customer_name       String? // Customer's name
  insurance           String? // Customer's insurance
  dob                 String? // Customer's date of birth
  // Add more clinic-specific call fields as identified from your CSVs.
  // Example: clinic_a_patient_tier String?
  // Example: clinic_b_referral_source String?

  company           Company           @relation(fields: [company_id], references: [id]) // Relation: A call belongs to one company
  agent             Agent             @relation(fields: [agent_id], references: [id]) // Relation: A call was handled by one agent
  human_evaluations HumanEvaluation[] // Relation: A call can have multiple human evaluations
  llm_evaluations   LlmEvaluation[] // Relation: A call can have multiple LLM evaluations
}

// --- Human Evaluation Table ---
// This table stores human evaluation data for each call performed by QA team members.
model HumanEvaluation {
  id           Int      @id @default(autoincrement()) // Unique identifier for the evaluation
  call_id      Int      @map("callId") // Foreign key to the Call table
  evaluator_id Int      @map("evaluatorId") // Foreign key to the User table
  timestamp    DateTime @default(now()) // Date and time when the evaluation was created

  // Human Evaluation Metrics
  overall_score     Float? // e.g., a numerical score from 1-5 or 1-100 (nullable)
  // politeness_score    Int? // e.g., 1-5 scale for agent politeness (nullable)
  resolution_status Boolean? // e.g., true if the issue was resolved (nullable)
  // accuracy_rating     String? // e.g., "High", "Medium", "Low" (nullable)
  // clarity_score       Int? // e.g., 1-5 scale for agent clarity (nullable)
  // empathy_score       Int? // e.g., 1-5 scale for agent empathy (nullable)
  // adherence_to_script Boolean? // e.g., if the agent followed a script (nullable)
  problem_solved    Boolean? // whether the customer's problem was solved (nullable)
  overall_comment   String?  @db.Text // Free-form human comment (nullable)
  // status            String? // Status from feedback engineer

  call      Call @relation(fields: [call_id], references: [id]) // Relation: A human evaluation belongs to one call
  evaluator User @relation(fields: [evaluator_id], references: [id]) // Relation: A human evaluation is linked to a user
}

// --- LLM Evaluation Table ---
// This table stores LLM-generated evaluation data for each call.
model LlmEvaluation {
  id        Int      @id @default(autoincrement()) // Unique identifier for the evaluation
  call_id   Int      @map("callId") // Foreign key to the Call table
  timestamp DateTime @default(now()) // Date and time when the evaluation was created

  // LLM Evaluation Metrics
  overall_score        Float? // e.g., a numerical score from 1-5 or 1-100 (nullable)
  politeness_score     Int? // e.g., 1-5 scale for agent politeness (nullable)
  resolution_status    Boolean? // e.g., true if the issue was resolved (nullable)
  accuracy_rating      String? // e.g., "High", "Medium", "Low" (nullable)
  clarity_score        Int? // e.g., 1-5 scale for agent clarity (nullable)
  empathy_score        Int? // e.g., 1-5 scale for agent empathy (nullable)
  adherence_to_script  Float? // e.g., if the agent followed a script (nullable)
  problem_solved       Boolean? // whether the customer's problem was solved (nullable)
  llm_summary          String?  @db.Text // LLM generated summary (nullable)
  llm_sentiment        String? // e.g., "Positive", "Negative", "Neutral" from LLM (nullable)
  feedback             String?  @db.Text // LLM feedback
  call_type            String? // LLM determined call type
  call_type_confidence Float?
  call_type_reasoning  String?  @db.Text
  sentiment_reasoning  String?  @db.Text
  sentiment_confidence Float?
  protocol_reasoning   String?  @db.Text
  protocol_confidence  Float?
  outcome_reasoning    String?  @db.Text
  outcome_confidence   Float?
  vapi_score           Float? // VAPI QA Score

  call Call @relation(fields: [call_id], references: [id]) // Relation: An LLM evaluation belongs to one call
}

enum SentimentValue {
  very_positive
  positive
  neutral
  negative
  very_negative
}
